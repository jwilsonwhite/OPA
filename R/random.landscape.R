#' Random landscape generation
#' 
#' Create a landscape with various types of point patterns: complete spatial randomness, overdispersion, or underdispersion.
#' Can also create a landscape of objects, if object radii are provided. Uses FFT method based on Keitt (2000).
#' 
#' @author Will White, \email{whitejw@@uncw.edu}
#'
#'@param res the resolution of the landscape lattice. This is width (in number of lattice points) of the square study area, or diameter of the circular study area. A value â‰¥ 100 is recommended to approximate a continuous non-lattice landscape
#'@param n number of points in the landscape
#'@param units the dimensions of the landscape (width of a square or diameter of a circle) in the desired units for x and y. For example, \code{units = 10} will produce \code{x} and \code{y} values that range from 0 to 10. 
#'@param range.pts the target autocorrelation scale of the point pattern data. A value greater than 0 and less than or equal to 1 will produce 
#'        a random distribution (the actual value does not matter if it falls within that range). A value > 1 
#'        produces an autocorrelated pattern with the specified autocorrelation range. A value < 0 produces an underdispersed 
#'        pattern with that minimum distance between points (objects). A value of 0 produces an error.
#'@param range.radii the target autocorrelation scale of the object radii. This has the same usage as range.points, 
#'       but acts on the object radii instead of the object centroids So values between 0 and 1 assign radii at random; values > 1 produce objects 
#'       with radii that are spatially autocorrelated, and values < 0 produce a pattern in which objects repel each 
#'       other at a scale equal to range.radii/2 beyond the boundary of their object
#'       edge. In other words there will be a minimum distance of range.radii between the edges of any object.
#'@param radius.mean the mean of the object radii. Be advised that if values are too large then very few points will be
#'       able to fit on the landscape.  
#'@param radius.sd the standard deviation of the object radii. Be advised that if the standard deviation is very large relative to
#'       the mean then many objects will be constrained to have radius 0 and the radii will have a truncated size distribution.
#'@param Type character string indicating the shape of the study area. Must be either \code{'rect'} (default) or \code{'circle'}.
#' 
#'@export
#'@return An object of class \code{"ppp"} containing coordinates for each object in fields \code{x} and \code{y}. Object radii are in the field \code{marks}
#'  
#' @examples 
#' random.landscape()
#' 
#' @seealso \code{\link{sim.autocorr}},  \code{\link{K.obj}}, \code{\link[spatstat]{ppp.object}}
#' @references \href{http://link.springer.com/article/10.1023/A:1008193015770}{Keitt (2000)}
#' 
#' 

random.landscape <- function(units=10,n=10,res = 100,range.pts = 1,range.radii = 1,radius.mean=NULL,radius.sd=1,Type='rect'){

  # error checking:
  try(if(range.pts==0) stop("range.pts cannot be 0",call.=FALSE))
  try(if(range.radii==0) stop("range.radii cannot be 0",call.=FALSE))
  try(if(radius.sd<0) stop("radius.sd must be >= 0",call.=FALSE))
  try( if(!any(Type==c('circle','rect'))) stop("Type must be either 'circle' or 'rectangle'",call.=FALSE))
  
# A rectangular landscape will be generated by sim.autocorr(), so if Type == 'circle', the corners will simply be trimmed off.
# Therefore to achieve the desired number of points, n must be rescaled accordingly.
  if (Type == 'circle'){
    # The ratio of the area of a rectangle with side res and the area of a circle with diameter res is 4/pi
    n = n*4/pi}
  
# Simulate points.  Choose whether they will be random, autocorrelated, or underdispersed with respect to the point-pattern
# This will be a square of dimension res, with values distributed ~N(0,1)
# with spatial scale range.pts

# If X should be underdispersed, apply that correction:
  if (range.pts < 0){
  D <- sim.autocorr(n=round(res),mean=0,sd=1,range=1,dimension=2)
  D <- discretize(D,n) # convert into discrete points
  D <- overdisperse(D,abs(range.pts))
  }else{ #otherwise, random or autocorrelated
  D <- sim.autocorr(n=round(res),mean=0,sd=1,range=range.pts,dimension=2);
  D <- discretize(D,n) # convert into discrete points
  } # end if/else

  
# Simulate radii.  Eliminate overlapping points.  Choose whether they should be random, autocorrelated, or dispersed with respect to radii.
if (!is.null(radius.mean)){
  if (range.radii < 0){
    R <- sim.autocorr(n=round(res),mean=radius.mean,sd=radius.sd,range=1,dimension=2) # random distribution of radii
    R[R<0] <- 0 # constrain to be >= 0
  # Eliminate points that overlap given radius + sill_radii
    D <- no.overlap(D,R + abs(range.radii)/2) # but add in 1/2 of sill to each point
  }else{ 
  R <- sim.autocorr(n=round(res),mean=radius.mean,sd=radius.sd,range=range.radii,dimension=2)
  R[R<0] <- 0 # constrain to be >= 0
  # Eliminate points that overlap
  D = no.overlap(D,R)
  } # end if/else
}else{ # end if !null
  R = rep(0,res^2)}
  


# Convert into ppp object of X, Y points + Radii
N = dim(D)[1]
x <- matrix(rep(1:N,N),N,N) # matrix of x values
y <- t(x) # matrix of y values
H <- sort(D,decreasing=TRUE,index.return=TRUE)
OK <- 1:n
X <- x[H$ix[OK]]
Y <- y[H$ix[OK]]
R <- R[H$ix[OK]]

# Scale to correct units
Scaling = units/res
X <- X*Scaling
Y <- Y*Scaling
res <- res*Scaling

# If a circle, eliminate points beyond the radius:
if (Type == 'circle'){
  X = X-res/2
  Y = Y-res/2
  OK = sqrt(X^2 + Y^2) <(res/2) 
  X <- X[OK]
  Y <- Y[OK]
  R <- R[OK]
  P<-ppp(X,Y,marks=R,window=disc(radius=maxR/2))
}else{ # if a rectangle
P<-ppp(X,Y,marks=R,xrange=c(0,res),yrange=c(0,res))
} 
P}# end function